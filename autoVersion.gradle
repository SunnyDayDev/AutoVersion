import groovy.swing.SwingBuilder
import org.gradle.api.provider.PropertyState

apply plugin: AutoVersionPlugin

class AutoVersionPlugin implements Plugin<Project> {

    Project project

    @Override
    void apply(Project project) {

        this.project = project

        AutoVersionExtension extension = project.extensions.create('autoVersion', AutoVersionExtension, project)

        extension.plugin = this

        AutoVersionTask prepeareAutoVersion = project.tasks.create('prepeareAutoVersion', AutoVersionTask) {
            propsFile = getVersionFile()
            lastBuildReleaseNotes = new File(getLastBuildReleaseNoteFile())
        }

        project.tasks.findByName("preBuild").dependsOn prepeareAutoVersion

        project.gradle.taskGraph.whenReady { graph ->

            prepeareAutoVersion.autoVersion = graph.allTasks
                    .any { task -> task.name in extension.autoVersionForTasks }

        }

    }

    int getIncrementalVersionCode() {

        Properties versionProperties = new Properties()
        File propsFile = getVersionFile()

        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        Integer code = versionProperties["VERSION_CODE"].toString().toInteger()

        return code > 0 ? code : 1
    }

    String getIncrementalVersionName() {

        Properties versionProperties = new Properties()
        File propsFile = getVersionFile()

        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        return versionProperties["VERSION_NAME"]
    }

    String getLastBuildReleaseNoteFile() {

        String path = project.projectDir.absolutePath + "/autoVersion/lastBetaBuildNotes.txt"

        File lastbuildNote = new File(path)

        if (!lastbuildNote.exists()) {

            lastbuildNote.parentFile.mkdirs()
            lastbuildNote.createNewFile()
            lastbuildNote.write("Initial release note.")

        }

        return lastbuildNote.toString()
    }

    private File getVersionFile() {

        String path = project.projectDir.absolutePath + '/autoVersion/version.properties'

        File versionPropsFile = new File(path)

        if (!versionPropsFile.exists()){

            versionPropsFile.parentFile.mkdirs()
            versionPropsFile.createNewFile()
            versionPropsFile.write("#Initial empty AutoVersion props\nVERSION_CODE=0\nVERSION_NAME=0.0.1")

        }

        return versionPropsFile
    }

}

class AutoVersionExtension {

    private final PropertyState<String[]> autoVersionForTasks

    AutoVersionPlugin plugin

    AutoVersionExtension(Project project) {
        autoVersionForTasks = project.property(Task[])
        autoVersionForTasks.set([])
    }

    String[] getAutoVersionForTasks() {
        autoVersionForTasks.get()
    }

    void setAutoVersionForTasks(String[] tasks) {
        autoVersionForTasks.set(tasks)
    }

    Integer getIncrementalVersionCode() {
        plugin.incrementalVersionCode
    }

    String getIncrementalVersionName() {
        plugin.incrementalVersionName
    }

    String getLastBuildReleaseNoteFile() {
        plugin.lastBuildReleaseNoteFile
    }

}

class AutoVersionTask extends DefaultTask {

    private Properties versionProperties
    private File propsFile
    private File lastBuildReleaseNotes

    boolean autoVersion = false

    @TaskAction
    def update() {

        if (!autoVersion) return

        checkVersionChanges()

    }

    void setAutoVersion(boolean autoVersion) {
        this.autoVersion = autoVersion
    }

    void setLastBuildReleaseNotes(File file) {
        this.lastBuildReleaseNotes = file
    }

    void setPropsFile(File propsFile) {

        Properties versionProperties = new Properties()
        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        this.propsFile = propsFile
        this.versionProperties = versionProperties
    }

    private void checkVersionChanges() {

        Integer[] versions = versionProperties["VERSION_NAME"].toString()
                .split("\\.")
                .collect { it.toInteger() }
        Integer currentVersionCode = versionProperties["VERSION_CODE"].toString().toInteger()

        boolean cancelled = true

        String lastBuildNotes = lastBuildReleaseNotes.readLines().join("\n")

        new SwingBuilder().edt {

            dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
                    title: 'Build version.', // Dialog title
                    alwaysOnTop: true, // pretty much what the name says
                    resizable: false, // Don't allow the user to resize the dialog
                    locationRelativeTo: null, // Place dialog in center of the screen
                    pack: true, // We need to pack the dialog (so it will take the size of it's children)
                    show: true // Let's show it
            ) {

                def releaseNotesInput
                def newVersionLabel

                Integer[] increments = [0, 0, 0, 1]

                def updateVersion = {

                    String global = versions[0].toInteger() + increments[0]
                    String major = versions[1].toInteger() + increments[1]
                    String minor = versions[2].toInteger() + increments[2]
                    String build = currentVersionCode + increments[3]

                    newVersionLabel.text = "New version: $global.$major.$minor($build)"
                }

                vbox { // Put everything below each other

                    hbox {
                        label text: "Current version: ${versions.join(".")}($currentVersionCode)"
                    }

                    hbox {
                        label text: "What version changes?"
                    }


                    hbox {

                        button text: '1.x.x', actionPerformed: {
                            increments[0] = increments[0] + 1
                            updateVersion() // Close dialog
                        }

                        button text: 'x.1.x', actionPerformed: {
                            increments[1] = increments[1] + 1
                            updateVersion() // Close dialog
                        }

                        button text: 'x.x.1', actionPerformed: {
                            increments[2] = increments[2] + 1
                            updateVersion() // Close dialog
                        }

                    }

                    hbox {

                        button text: '0.x.x', actionPerformed: {
                            increments[0] = -versions[0]
                            updateVersion()
                        }

                        button text: 'x.0.x', actionPerformed: {
                            increments[1] = -versions[1]
                            updateVersion()
                        }

                        button text: 'x.x.0', actionPerformed: {
                            increments[2] = -versions[2]
                            updateVersion()
                        }

                    }

                    hbox {

                        button text: 'Build number', actionPerformed: {
                            increments[3] = increments[3] + 1
                            updateVersion() // Close dialog
                        }

                        button text: 'Reset', actionPerformed: {
                            increments[0] = 0
                            increments[1] = 0
                            increments[2] = 0
                            increments[3] = 1

                            updateVersion() // Close dialog
                        }
                    }

                    hbox {
                        newVersionLabel = label text: ""
                        updateVersion()
                    }

                    hbox {
                        releaseTitle = label text: 'Release notes:'
                    }

                    releaseNotesInput = textArea text: lastBuildNotes, preferredSize: [400, 300]

                    hbox {

                        button text: 'Ok', actionPerformed: {

                            versions[0] = versions[0] + increments[0]
                            versions[1] = versions[1].toInteger() + increments[1]
                            versions[2] = versions[2].toInteger() + increments[2]

                            currentVersionCode = currentVersionCode + increments[3]

                            lastBuildNotes = releaseNotesInput.text

                            cancelled = false

                            dispose()
                        }

                        button text: 'Cancel', actionPerformed: {
                            cancelled = true
                            dispose() // Close dialog
                        }

                    }

                } // vbox end

            } // dialog end

        } // edt end


        if (cancelled){
            throw new Exception("Cancelled.")
        }

        versionProperties["VERSION_NAME"] = versions.join(".")
        versionProperties["VERSION_CODE"] = String.valueOf(currentVersionCode)

        versionProperties.store(propsFile.newWriter(), null)
        lastBuildReleaseNotes.write(lastBuildNotes)

    }

}

/**
 * Result apk naming.
 */

/*
 * Result apk naming.
 */
/*
android.applicationVariants.all { variant ->
    def appName
    //Check if an applicationName property is supplied; if not use the name of the parent project.
    if (project.hasProperty("applicationName")) {
        appName = applicationName
    } else {
        appName = parent.name
    }

    variant.outputs.each { output ->
        def newApkName
        //If there's no ZipAlign task it means that our artifact will be unaligned and we need to mark it as such.
        if (output.zipAlign) {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}.apk"
        } else {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}-unaligned.apk"
        }
        output.outputFile = new File(output.outputFile.parent, newApkName)
    }
}
*/
/*android.applicationVariants.all { variant ->

    def appName
    //Check if an applicationName property is supplied; if not use the name of the parent project.
    if (project.hasProperty("applicationName")) {
        appName = applicationName
    } else {
        appName = parent.name
    }

    variant.outputs.all { output ->
        def newApkName
        //If there's no ZipAlign task it means that our artifact will be unaligned and we need to mark it as such.
        if (output.zipAlign) {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}.apk"
        } else {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}-unaligned.apk"
        }
        outputFileName = newApkName
    }
}*/