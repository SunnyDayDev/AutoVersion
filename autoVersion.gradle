import groovy.swing.SwingBuilder
import org.gradle.api.provider.PropertyState

apply plugin: AutoVersionPlugin

class AutoVersionPlugin implements Plugin<Project> {

    Project project

    @Override
    void apply(Project project) {

        this.project = project

        AutoVersionExtension extension = project.extensions.create('autoVersion', AutoVersionExtension, project)

        extension.plugin = this

        AutoVersionTask prepeareAutoVersion = project.tasks.create('prepeareAutoVersion', AutoVersionTask) {
            propsFile = getVersionFile()
        }

        project.tasks.findByName("preBuild").dependsOn prepeareAutoVersion

        project.gradle.taskGraph.whenReady { graph ->

            prepeareAutoVersion.autoVersion = graph.allTasks
                    .any { task -> task.name in extension.autoVersionForTasks }

        }

    }

    int getIncrementalVersionCode() {

        Properties versionProperties = new Properties()
        File propsFile = getVersionFile()

        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        return versionProperties["VERSION_CODE"].toString().toInteger()
    }

    String getIncrementalVersionName() {

        Properties versionProperties = new Properties()
        File propsFile = getVersionFile()

        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        return versionProperties["VERSION_NAME"]
    }

    def getLastBuildReleaseNoteFile() {

        def lastbuildNote = project.file(project.projectDir.absolutePath + "/lastBetaBuildNotes.txt")

        if (!lastbuildNote.exists()){
            new File(project.projectDir.absolutePath + "/lastBetaBuildNotes.txt").withWriterAppend { w ->
                w << "Initial release note."
            }
        }

        return project.projectDir.absolutePath + "/lastBetaBuildNotes.txt"
    }

    private File getVersionFile() {

        def versionPropsFile = project.file(project.projectDir.absolutePath + '/version.properties')

        if (!versionPropsFile.exists()){
            versionPropsFile = new File(project.projectDir.absolutePath + '/version.properties').withWriterAppend { w ->
                w << ""
            }
        }

        return versionPropsFile
    }

}

class AutoVersionExtension {

    private final PropertyState<String[]> autoVersionForTasks

    AutoVersionPlugin plugin

    AutoVersionExtension(Project project) {
        autoVersionForTasks = project.property(Task[])
        autoVersionForTasks.set([])
    }

    String[] getAutoVersionForTasks() {
        autoVersionForTasks.get()
    }

    void setAutoVersionForTasks(String[] tasks) {
        autoVersionForTasks.set(tasks)
    }

    Integer getIncrementalVersionCode() {
        plugin.incrementalVersionCode
    }

    String getIncrementalVersionName() {
        plugin.incrementalVersionName
    }

    String getLastBuildReleaseNoteFile() {
        plugin.lastBuildReleaseNoteFile
    }

}

class AutoVersionTask extends DefaultTask {

    private Properties versionProperties
    private File propsFile

    boolean autoVersion = false

    @TaskAction
    def update() {

        if (!autoVersion) return

        if(checkAndInit(versionProperties) | checkVersionChanges(versionProperties)) {

            versionProperties.store(propsFile.newWriter(), null)

        }
    }

    void setAutoVersion(boolean autoVersion) {
        this.autoVersion = autoVersion
    }

    void setPropsFile(File propsFile) {

        Properties versionProperties = new Properties()
        if(propsFile.exists()) {
            versionProperties.load(new FileInputStream(propsFile))
        } else {
            throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
        }

        this.propsFile = propsFile
        this.versionProperties = versionProperties
    }

    private static boolean checkAndInit(Properties properties) {

        def changed = false

        if (properties["VERSION_NAME"] == null){
            properties["VERSION_NAME"] = "0.0.0"
            changed = true
        }

        if (properties["VERSION_CODE"] == null){
            properties["VERSION_CODE"] = "1"
            changed = true
        }

        return changed
    }

    private static boolean checkVersionChanges(Properties properties) {

        String[] versions = properties["VERSION_NAME"].toString().split("\\.")

        boolean cancelled = false
        boolean changed = true

        new SwingBuilder().edt {

            dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
                    title: 'Build version.', // Dialog title
                    alwaysOnTop: true, // pretty much what the name says
                    resizable: false, // Don't allow the user to resize the dialog
                    locationRelativeTo: null, // Place dialog in center of the screen
                    pack: true, // We need to pack the dialog (so it will take the size of it's children)
                    show: true // Let's show it
            ) {

                vbox { // Put everything below each other
                    label(text: "What version changes?")
                    button(text: 'Global (1.x.x)', actionPerformed: {
                        versions[0] = String.valueOf(versions[0].toInteger() + 1)
                        versions[1] = "0"
                        versions[2] = "0"
                        dispose() // Close dialog
                    })
                    button(text: 'Major (x.1.x)', actionPerformed: {
                        versions[1] = String.valueOf(versions[1].toInteger() + 1)
                        versions[2] = "0"
                        dispose() // Close dialog
                    })
                    button(text: 'Minor (x.x.1)', actionPerformed: {
                        versions[2] = String.valueOf(versions[2].toInteger() + 1)
                        dispose() // Close dialog
                    })
                    button(defaultButton: true, text: 'Internal (only buildNumber)', actionPerformed: {
                        dispose() // Close dialog
                    })
                    button(text: 'Same (nothing)', actionPerformed: {
                        changed = false
                        dispose() // Close dialog
                    })
                    button(text: 'Cancel', actionPerformed: {
                        cancelled = true
                        dispose() // Close dialog
                    })
                } // vbox end

            } // dialog end

        } // edt end

        if (cancelled){
            throw new Exception("Cancelled.")
        }

        if (changed) {
            properties["VERSION_NAME"] = versions.join(".")
            properties["VERSION_CODE"] = String.valueOf(properties["VERSION_CODE"].toString().toInteger() + 1)
        }

        return changed

    }

}

/**
 * Result apk naming.
 */

/*
 * Result apk naming.
 */
/*
android.applicationVariants.all { variant ->
    def appName
    //Check if an applicationName property is supplied; if not use the name of the parent project.
    if (project.hasProperty("applicationName")) {
        appName = applicationName
    } else {
        appName = parent.name
    }

    variant.outputs.each { output ->
        def newApkName
        //If there's no ZipAlign task it means that our artifact will be unaligned and we need to mark it as such.
        if (output.zipAlign) {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}.apk"
        } else {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}-unaligned.apk"
        }
        output.outputFile = new File(output.outputFile.parent, newApkName)
    }
}
*/
/*android.applicationVariants.all { variant ->

    def appName
    //Check if an applicationName property is supplied; if not use the name of the parent project.
    if (project.hasProperty("applicationName")) {
        appName = applicationName
    } else {
        appName = parent.name
    }

    variant.outputs.all { output ->
        def newApkName
        //If there's no ZipAlign task it means that our artifact will be unaligned and we need to mark it as such.
        if (output.zipAlign) {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}.apk"
        } else {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}-unaligned.apk"
        }
        outputFileName = newApkName
    }
}*/